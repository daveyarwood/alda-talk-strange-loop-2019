= Alda's Dynamic Relationship With Clojure
Dave Yarwood <dave.yarwood@gmail.com>
:source-highlighter: rouge

== TODO

* Look into `slidy` as a way to generate an HTML slideshow from AsciiDoc
  documents.
** http://www.w3.org/Talks/Tools/Slidy2/
** http://asciidoc.org/slidy.html

== Tentative outline

=== Introduction

_2 minutes_

* This talk is about Alda, a music composition programming language that I
  started to work on in 2012.
* Little bit about me...
* I've given a few talks in the past where I introduced Alda and talked about
  the features of the language and how I use it to compose music.
* I will try to cover a little bit of that today in the fastest way possible,
  but for this talk, I'd like to focus more on the history of Alda and its
  interesting relationship with Clojure.
* If you're curious to hear more about the syntax and features of Alda, I would
  encourage you to watch my previous talks, and also check out the Alda website,
  which has links to documentation and a tutorial.

=== Agenda

_1 minute_

* Cover the items below and hint that I will be making a shocking announcement
  (I plan to reimplement Alda using Go and Kotlin)

=== Quick demo: Alda

_5 minutes_

* Show and play examples in editor.

* Go super light on the inline Clojure code, show just enough so that it's clear
  that it's currently a feature of Alda.
** alda-clj demo at the end of the talk will cover the same functionality

=== Evolution of Alda's architecture

==== phase 1: just a single clojure program that does everything

_1 minute_

==== phase 2: break out client as java program for better CLI experience

_1 minute_

==== phase 3: replace server implementation (http -> zmq REQ/REP)

_2 minutes_

* brief introduction to ZeroMQ, a couple of socket types
* REQ/REP
* "lazy pirate" pattern for client-side reliability

==== phase 4: add a worker process (zmq "paranoid pirate" pattern)

_2 minutes_

* need for server-side reliability
* DEALER/ROUTER sockets, "paranoid pirate" pattern
* increased complexity at this point, foisted upon the user to some extent

==== next phase

===== move most functionality into the client

_1 minute_

* server and worker go away
* new objective: client must be fast af
** and have minimal startup time
** native executable?

===== minimal player process

_4 minutes_

* performs a minimal amount of what the worker currently performs, namely
  playback

* necessary to be a separate process because playback happens asynchronously

* new objective: general purpose
** could be driven by something other than the alda client
** driven by OSC
*** simpler than ZeroMQ, better track record of use for realtime audio
    applications
*** already supported by lots of things, a standard for audio programming

* brief introduction to OSC

* new objective: support live-coding

===== shocking announcement

_3 minutes_

* i plan to reimplement alda using go and kotlin
** ...although maybe i won't?  graalvm and cljs->node are also options
** the point is, i've decided to decouple alda from clojure
*** enumerate reasons here (refer to alda-clj "history" document)
*** i realized that i could still use clojure to write alda scores in a way
    that doesn't require alda to be implemented in clojure
*** micha mentioned clojure's value as a prototyping language, words i've
    taken to heart
*** i was able to use clojure to quickly iterate to where alda is now, a feat
    that would have been tedious in a less concise/expressive language
*** the work at this point is simply to port the logic to a language better
    equipped to meet my goals for alda

=== alda-clj

_4 minutes_

* show github repo
** basic example under Usage in README
** cljdoc: API docs, Getting Started guide

* Benefits of it being a Clojure library instead of built into Alda
** not tied to the set of dependencies included in the alda runtime
** full control of the program, can run it wherever you like
*** e.g. a script, a web application
** can leverage cljdoc to provide API docs

* Demonstrate basic usage in editor-connected REPL

* Demonstrate something you can do with alda-clj that you can't do with inline
  Clojure code in an Alda score.
** e.g. use a Clojure library to make music

=== take questions

_4 minutes_

== Scratchpad

* Hello, Strange Loop! I'm here to tell you a story of love, marriage, and
  divorce. Not of people, but of programming languages.
** One of them is my brain-child, Alda.
** Alda is a music composition programming language, born in Durham.
** The other one is Clojure, a JVM Lisp, born in New York.

* In order to tell this story, I also need to tell you a little bit about my own
  progression as a software developer.
** Segue into background that led to me initially toying with writing Alda in
Python, then Ruby, finally settling on Clojure.
** Started working at Adzerk not long after switching to Clojure, received
input and development from my coworkers.

* Now before we get much further, I'd like to give you a quick demo of Alda,
  because I think that most of you probably aren't familiar with Alda, and you
  might want to know the characters in this story a little better.
** Demo of features using Alda v1.x
*** Don't necessarily need to tell the audience that this is an older version of
Alda right off the bat. The basic features of Alda should be consistent from v1
to v2. Including attributes, which I don't need to explain right away are
actually Lisp S-expressions.
*** Then demonstrate the inline Clojure code feature of Alda v1. Say something
to the effect of "I should mention that I'm using Alda v1.whatever here.
There's a good reason for that. It's because I want to show you this feature
that Alda used to have prior to version 2..."

