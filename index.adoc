= Alda's dynamic relationship with Clojure
:title-separator: {sp}|
:!sectids:
:imagesdir: images
:icons: font
:source-highlighter: highlightjs
:revealjs_customtheme: styles/djy.css
:revealjs_transition: none
:revealjs_transitionSpeed: fast
:revealjs_controls: false
:revealjs_progress: false
:highlightjs-theme: styles/gruvbox-dark.css

[.notes]
--
* Introduction
** 2 minutes
** This is a story about the relationship between two programming languages and
how it has evolved over time.
*** One of them is Alda, a text-based music composition language.
*** The other is Clojure, a functional programming-oriented Lisp that runs on
the JVM.
--

image:alda_logo.png[250,250]

<=[?]=>

image:clojure_logo.png[250,250]

== !

[cols="2*"]
|===
| image:dave-drums.jpg[Dave playing drums,450,450]
a|
[no-bullet]
* Music degree (UNC '08)
* Alda creator/BDFL (2012-)
* Software engineer at Adzerk (2014-)
* icon:github[] *daveyarwood*
* icon:twitter[] *@dave_yarwood*
* image:keybase-logo.svg[keybase logo,25,25,role=inline] *daveyarwood*
* icon:globe[] *djy.io, alda.io*
|===

== Adzerk

[.notes]
--
* I like this excerpt of our Senior Open Source Engineer job posting:
** Adzerk is a world-class software platform for decision-making at scale.  Our
ever-growing list of customers include the most innovative applications and
publishers in the world, like Strava, Ticketmaster, Edmunds, WeTransfer, and
imgur.
** Great description of our product, emphasizing that we're essentially a
decision engine.
*** Can use the decision engine for ad serving, dynamic content selection or
other purposes.
--

* Decision making at scale
* Build your own fully custom ad server in weeks
* <3 Clojure <3
* We're hiring!
** https://adzerk.com/careers/[adzerk.com/careers]

== !

[.notes]
--
* Elevator pitch for Alda
** 1 minute
** Alda is a language for writing music in a text format.
** The text is your source code, which can parsed and interpreted by a playback
process, which allows you to hear the music that you're writing as you're
writing it.
** I was inspired to create Alda after I studied music composition and then I
got more into software development and I learned how I could use a text editor
and the command line to develop software interactively.
** I believe that a tight feedback loop is essential to unlocking your
creativity both when you're developing software and when you're composing music.
--

image::elevator.jpg[background]

== Music composition GUI

[.notes]
--
* Compare and contrast GUI vs. TUI music composition
** 5 minutes
--

[cols="3,2"]
|===
| image:sibelius.jpg[screenshot of Sibelius]
a|
* Mouse-oriented
* Distracting
* Cumbersome
* Limiting
|===

== !

[.notes]
--
* Relate the Sapir-Whorf hypothesis to the limiting aspect of composing music in
a GUI
--

image::snow_cone.jpg[Eskimos have many words for snow,600,600]

== Music composition TUI

[cols="3,2"]
|===
| image:jimenez_screenshot.png[editing an Alda score]
a|
* Keyboard-oriented
* Focused
* Efficient
* Liberating
|===

== Demo: Alda v1

* Just a quick survey of features
* To learn more about Alda:
** https://alda.io (docs, tutorial)
** https://github.com/alda-lang/alda
** Previous talks on YouTube

[.notes]
--
* 10 minutes (maybe less now? need to time it again)
** See alda files in demo/alda-v1
** Keep explanations short!
** Don't necessarily even need to play every line of code.
** Just want to quickly show what you can do with Alda and how it can achieve
things that can't be easily expressed in standard musical notation.
--

== !

[.notes]
--
The evolution of Alda's architecture
--

image::blueprint.jpg[background]

== Phase 1: Single program

[.notes]
--
1 minute
phase 1: just a single clojure program that does everything
--

image::phase1.svg[]

== Phase 1: Single program

[%step]
* Problem: Clojure startup time
* Problem: Blocks until playback is complete

== Phase 2: Client/server (HTTP)

[.notes]
--
1 minute
phase 2: break out client as java program for better CLI experience
--

image::phase2.svg[]

== Phase 2: Client/server (HTTP)

[%step]
* [.line-through]#Problem: Clojure startup time#
* [.line-through]#Problem: Blocks until playback is complete#
* Problem: HTTP is a bit overkill for IPC
* Problem: Audio glitches when playing multiple scores

== Phase 3: Client/server (ZeroMQ)

[.notes]
--
2 minutes
phase 3: replace server implementation (http -> zmq REQ/REP)
--

image::phase3.svg[]

== !

.Screenshot of zeromq.org, 2017
[caption=""]
image::zmq_pitch.png[]

== !

image::zmq_req_rep.png[background, size=25%]

== Phase 3: Client/server (ZeroMQ)

[%step]
* [.line-through]#Problem: HTTP is a bit overkill for IPC#
* Problem: Audio glitches when playing multiple scores

== Phase 4: Client/server/workers

[.notes]
--
2 minutes
phase 4: add a worker process (zmq "paranoid pirate" pattern)

* need for server-side reliability
* DEALER/ROUTER sockets, "paranoid pirate" pattern
* increased complexity at this point, foisted upon the user to some extent
--

image::phase4.svg[]

== !

image::alda_zmq_architecture.svg[]

== Phase 4: Client/server/workers

[%step]
* [.line-through]#Problem: Audio glitches when playing multiple scores#
* Problem: This is getting complicated.
* Problem: User needs to manage server & workers
* Problem: Can't do anything if workers are busy

== Alda v2 wishlist

[.notes]
--
1 minute
--

[%step]
* Move most functionality into the client
** No more server/workers
* Fast startup time / execution
** Native executable
* Support for live coding
** Edit a score on the fly while it's playing

== Phase 5: Client/player

image::phase5.svg[]

[.notes]
--
4 minutes

* performs a minimal amount of what the worker currently performs, namely
playback

* necessary to be a separate process because playback happens asynchronously
--

== Open Sound Control (OSC)

* http://opensoundcontrol.org
* De facto standard for multimedia communication
* Transported over UDP
* Simple, open-ended message structure
** `/track/1/midi/note 2000 61 500 500 127`

== Phase 5: Client/player

[.notes]
--
* next slide
--

image::phase5.svg[]

== Phase 5: Client/player

[.notes]
--
3 minutes

* i plan to reimplement alda using go and kotlin
** primary objective: decouple alda from clojure
** i'm also taking the opportunity to switch to languages/runtimes that i think
are better able to help me achieve my goals for alda
*** enumerate reasons here (refer to alda-clj "history" document)
*** maybe discuss alternatives: graalvm, cljs->node
--

image::phase5a.svg[]

== Phase 5: Client/player

[.shift-up-30px]
image::phase5b.svg[]

[.notes]
--
* i realized that i could still use clojure to write alda scores in a way
that doesn't require alda to be implemented in clojure
* micha mentioned clojure's value as a prototyping language, words i've
taken to heart
* i was able to use clojure to quickly iterate to where alda is now, a feat
that would have been tedious in a less concise/expressive language
--

== !

image::alda-clj.png[]

[.notes]
--
4 minutes

* Benefits of it being a Clojure library instead of built into Alda
** not tied to the set of dependencies included in the alda runtime
** full control of the program, can run it wherever you like
*** e.g. a script, a web application
** can leverage cljdoc to provide API docs
** Clojure's REPL-driven development experience unlocks my creativity
*** Easier to experiment with Clojure code than it is from within Alda
--

== Demo: alda-clj

[.notes]
--
5 minutes

* Demonstrate basic usage in editor-connected REPL
* _Meteorology_ piece
--

== take questions

5 minutes

== TODO

* Flesh out slides enough that I can practice going through the talk from start
to finish and time it.
* I suspect that I might be over time at this point.
** If I am, may need to trim some things down.
