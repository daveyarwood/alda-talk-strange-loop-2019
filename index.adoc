= Alda's dynamic relationship with Clojure
:title-separator: {sp}|
:!sectids:
:imagesdir: images
:icons: font
:source-highlighter: highlightjs
:revealjs_customtheme: styles/djy.css
:revealjs_transition: none
:revealjs_transitionSpeed: fast
:revealjs_controls: false
:revealjs_progress: false
:highlightjs-theme: styles/gruvbox-dark.css

[.notes]
--
* Introduction
** 2 minutes
** I'm here to tell a story about the relationship between two programming
languages.
*** One of them is Alda, a text-based music composition language.
*** The other is Clojure, a functional programming-oriented Lisp that runs on
the JVM.
*** Slide: about me
*** Slide: about Adzerk
--

image:alda_logo.png[250,250]

<=[?]=>

image:clojure_logo.png[250,250]

== !

[cols="2*"]
|===
| image:dave-drums.jpg[Dave playing drums,450,450]
a|
[no-bullet]
* Music degree (UNC '08)
* Alda creator/BDFL (2012-)
* Software engineer at Adzerk (2014-)
* icon:github[] *daveyarwood*
* icon:twitter[] *@dave_yarwood*
* image:keybase-logo.svg[keybase logo,25,25,role=inline] *daveyarwood*
* icon:globe[] *djy.io, alda.io*
|===

== TODO: Adzerk slide

_[insert marketing jargon here]_

== !

[.notes]
--
* Elevator pitch for Alda
** 1 minute
** Alda is a language for writing music in a text format.
** The text is your source code, which can parsed and interpreted by a playback
process, which allows you to hear the music that you're writing as you're
writing it.
** I was inspired to create Alda after I studied music composition and then I
got more into software development and I learned how I could use a text editor
and the command line to develop software interactively.
** I believe that a tight feedback loop is essential to unlocking your
creativity both when you're developing software and when you're composing music.
--

image::elevator.jpg[background]

== Music composition GUI

[.notes]
--
* Compare and contrast GUI vs. TUI music composition
** 5 minutes
--

TODO: screenshot of Sibelius

* Mouse-oriented
* Distracting
* Cumbersome
* Limiting

== !

[.notes]
--
* Relate the Sapir-Worff hypothesis to the limiting aspect of composing music in
a GUI
--

TODO: find an image that illustrates the Sapir-Worff hypothesis

== Music composition TUI

[cols="2*"]
|===
| image:jimenez_screenshot.png[editing an Alda score]
a|
* Keyboard-oriented
* Focused
* Efficient
* Liberating
|===

== Demo: Alda v1

* Just a quick survey of features
* To learn more about Alda:
** https://alda.io (docs, tutorial)
** https://github.com/alda-lang/alda
** Previous talks on YouTube

[.notes]
--
* 10 minutes
** See alda files in demo/alda-v1
** Keep explanations short!
** Don't necessarily even need to play every line of code.
** Just want to quickly show what you can do with Alda and how it can achieve
things that can't be easily expressed in standard musical notation.
--

== Evolution of Alda's architecture

== phase 1: just a single clojure program that does everything

1 minute

== phase 2: break out client as java program for better CLI experience

1 minute

== phase 3: replace server implementation (http -> zmq REQ/REP)

2 minutes

* brief introduction to ZeroMQ, a couple of socket types
* REQ/REP
* "lazy pirate" pattern for client-side reliability

== phase 4: add a worker process (zmq "paranoid pirate" pattern)

2 minutes

* need for server-side reliability
* DEALER/ROUTER sockets, "paranoid pirate" pattern
* increased complexity at this point, foisted upon the user to some extent

== next phase

== move most functionality into the client

1 minute

* server and worker go away
* new objective: client must be fast af
** and have minimal startup time
** native executable?

== minimal player process

4 minutes

* performs a minimal amount of what the worker currently performs, namely
playback

* necessary to be a separate process because playback happens asynchronously

* new objective: general purpose
** could be driven by something other than the alda client
** driven by OSC
*** simpler than ZeroMQ, better track record of use for realtime audio
applications
*** already supported by lots of things, a standard for audio programming

* brief introduction to OSC

* new objective: support live-coding

== shocking announcement

3 minutes

* i plan to reimplement alda using go and kotlin
** primary objective: decouple alda from clojure
** i'm also taking the opportunity to switch to languages/runtimes that i think
are better able to help me achieve my goals for alda
*** enumerate reasons here (refer to alda-clj "history" document)
*** i realized that i could still use clojure to write alda scores in a way
that doesn't require alda to be implemented in clojure
*** micha mentioned clojure's value as a prototyping language, words i've
taken to heart
*** i was able to use clojure to quickly iterate to where alda is now, a feat
that would have been tedious in a less concise/expressive language
** maybe discuss alternatives: graalvm, cljs->node

== alda-clj

4 minutes

* show github repo
** basic example under Usage in README
** cljdoc: API docs, Getting Started guide

* Benefits of it being a Clojure library instead of built into Alda
** not tied to the set of dependencies included in the alda runtime
** full control of the program, can run it wherever you like
*** e.g. a script, a web application
** can leverage cljdoc to provide API docs
** Clojure's REPL-driven development experience unlocks my creativity
*** Easier to experiment with Clojure code than it is from within Alda

== Demo: alda-clj

[.notes]
--
5 minutes

* Demonstrate basic usage in editor-connected REPL
* _Meteorology_ piece
--

== take questions

4 minutes

== TODO

* I'm under budget for time. I may want to dive deeper into some interesting
areas to fill time.
** Ideas for additional things to discuss:
*** Exploration of languages/runtimes available for creating native executables
and why I decided to go with Go.
**** Go
**** Rust
**** Crystal
**** Clojure w/ GraalVM
**** ClojureScript targeting Node.js
*** Experience report of porting Clojure code to Go
*** Fill up more time with cool demos
