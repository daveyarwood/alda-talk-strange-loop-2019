= Alda's dynamic relationship with Clojure
:title-separator: {sp}|
:!sectids:
:imagesdir: images
:icons: font
:source-highlighter: highlightjs
:revealjs_customtheme: styles/djy.css
:revealjs_transition: none
:revealjs_transitionSpeed: fast
:revealjs_controls: false
:revealjs_progress: false
:highlightjs-theme: styles/gruvbox-dark.css

image:alda_logo.png[250,250]

<=[?]=>

image:clojure_logo.png[250,250]

[.notes]
--
* Introduction
** 2 minutes
** Good afternoon! I'm here to tell a story about the relationship between two
  programming languages.
*** One of them is Alda, a text-based music composition language.
*** The other is Clojure, a functional Lisp that runs on the JVM.
--

== !

[cols="2*"]
|===
| image:dave-drums.jpg[Dave playing drums,450,450]
a|
[no-bullet]
* Music degree (UNC '08)
* Alda creator/BDFL (2012-)
* Software engineer at Adzerk (2014-)
* icon:github[] *daveyarwood*
* icon:twitter[] *@dave_yarwood*
* image:keybase-logo.svg[keybase logo,25,25,role=inline] *daveyarwood*
* icon:globe[] *djy.io, alda.io*
|===

== TODO: Adzerk slide

_[insert marketing jargon here]_

== !

image::elevator.jpg[background]

[.notes]
--
* Brief description / elevator pitch of Alda
** 1 minute
** In 2012, I had a little daydream about what it might be like if I could compose music in a way similar to the way that I develop software.
** I found that I was more productive in a command-line environment using a
simple text editor without all of the features of an IDE.
** I wondered if I could compose music in an environment like that.
** Would a text-based language allow me to express all of the concepts I'd
learned in music theory and composition classes?
** Would it make me more productive?
** How might the creative process be different?
--

== Quick demo: Alda

[.notes]
5 minutes
--
* Before we get much further, I'm going to give you a quick demo of Alda.
  If you were here at Strange Loop during the past couple years, you may have
  seen me give a lightning talk with a live demonstration, like I'm about to do
  here.
** I've given a few talks in the past where I introduced Alda and I talked about
the features of the language and how I use it to compose music.
** I will try to cover a little bit of that today in the fastest way possible,
but for this talk, I'd like to focus more on the history of Alda and its
interesting relationship with Clojure.
** If you're curious to hear more about the syntax and features of Alda, I would
encourage you to watch my previous talks, and also check out the Alda website,
which has links to documentation and a tutorial.

* Show and play examples in editor.
** Demo of features using Alda v1.x
** Don't necessarily need to tell the audience that this is an older version of
Alda right off the bat. The basic features of Alda should be consistent from v1
to v2. Including attributes, which I don't need to explain right away are
actually Lisp S-expressions.
** Then demonstrate the inline Clojure code feature of Alda v1.
*** Say something to the effect of "I should mention that I'm using Alda
v1.whatever here.  There's a good reason for that. It's because I want to show
you this feature that Alda used to have built-in prior to version 2..."
*** alda-clj demo at the end of the talk will cover the same functionality
--

== Evolution of Alda's architecture

== phase 1: just a single clojure program that does everything

1 minute

== phase 2: break out client as java program for better CLI experience

1 minute

== phase 3: replace server implementation (http -> zmq REQ/REP)

2 minutes

* brief introduction to ZeroMQ, a couple of socket types
* REQ/REP
* "lazy pirate" pattern for client-side reliability

== phase 4: add a worker process (zmq "paranoid pirate" pattern)

2 minutes

* need for server-side reliability
* DEALER/ROUTER sockets, "paranoid pirate" pattern
* increased complexity at this point, foisted upon the user to some extent

== next phase

== move most functionality into the client

1 minute

* server and worker go away
* new objective: client must be fast af
** and have minimal startup time
** native executable?

== minimal player process

4 minutes

* performs a minimal amount of what the worker currently performs, namely
  playback

* necessary to be a separate process because playback happens asynchronously

* new objective: general purpose
** could be driven by something other than the alda client
** driven by OSC
*** simpler than ZeroMQ, better track record of use for realtime audio
    applications
*** already supported by lots of things, a standard for audio programming

* brief introduction to OSC

* new objective: support live-coding

== shocking announcement

3 minutes

* i plan to reimplement alda using go and kotlin
** primary objective: decouple alda from clojure
** i'm also taking the opportunity to switch to languages/runtimes that i think
are better able to help me achieve my goals for alda
*** enumerate reasons here (refer to alda-clj "history" document)
*** i realized that i could still use clojure to write alda scores in a way
    that doesn't require alda to be implemented in clojure
*** micha mentioned clojure's value as a prototyping language, words i've
    taken to heart
*** i was able to use clojure to quickly iterate to where alda is now, a feat
    that would have been tedious in a less concise/expressive language
** maybe discuss alternatives: graalvm, cljs->node

== alda-clj

4 minutes

* show github repo
** basic example under Usage in README
** cljdoc: API docs, Getting Started guide

* Benefits of it being a Clojure library instead of built into Alda
** not tied to the set of dependencies included in the alda runtime
** full control of the program, can run it wherever you like
*** e.g. a script, a web application
** can leverage cljdoc to provide API docs

* Demonstrate basic usage in editor-connected REPL

* Demonstrate something you can do with alda-clj that you can't do with inline
  Clojure code in an Alda score.
** e.g. use a Clojure library to make music

== take questions

4 minutes

== TODO

* I have a budget of 40 minutes, including time at the end for questions.
Currently, I have an estimated 30 minutes of material including time for
questions. I may want to dive deeper into some interesting areas.
** Ideas for additional things to discuss:
*** Exploration of languages/runtimes available for creating native executables
and why I decided to go with Go.
**** Go
**** Rust
**** Crystal
**** Clojure w/ GraalVM
**** ClojureScript targeting Node.js
*** Experience report of porting Clojure code to Go
*** Fill up more time with cool demos
